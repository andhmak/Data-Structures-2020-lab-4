![run-tests](../../workflows/run-tests/badge.svg)

## Δομές Δεδομένων και Τεχνικές Προγραμματισμού

### Κώδικας Εργαστηρίου 4

Εκφώνηση: https://k08.chatzi.org/labs/lab4/ <br>
Worst-case πολυπλοκότητες:<br>
Η παλιά heapify είχε πολυπλοκότητα Ο(nlogn), επειδή γίνονται n bubble-ups με πολυπλοκότητα logn το καθένα. Με την νέα υλοποίηση έχει πολυπλοκότητα Ο(n), αφού τα περοσσότερα bubble-downs δεν διασχίζουν όλο το δέντρο, γιατί βρίσκονται κοντά στην βάση του (η μαθηματική απόδειξη βρίσκεται στις διαφάνειες).<br>
Στην υλοποίηση μέσω ταξινομημένης λίστας:<br>
pqueue_size: πολυπλοκότητα Ο(1) αφού εκτελείται ένας αλγόριθμος ανεξάρτητος του μεγέθους (το size είναι ήδη αποθηκευμένο στην λίστα) (ίδια με του σωρού)<br>
pqueue_max: πολυπλοκότητα Ο(1) αφού διαβάζεται ο πρώτος (εκτός του dummy) κόμβος ανεξάρτητα από την υπόλοιπη λίστα (ίδια με του σωρού)<br>
pqueue_insert: πολυπλοκότητα Ο(n) αφού διασχίζεται η λίστα (επανάληψη με έως και n επαναλήψεις) (χειρότερη από του σωρού όπου είναι Ο(logn))<br>
pqueue_create: πολυπλοκότητα Ο(n^2) αφού εκτελείται μια pqueue_insert με πολυπλοκότητα Ο(n) για κάθε ένα από τα n αρχικά δεδομένα (ή Ο(1) αν δεν δίνονται αρχικά δεδομένα) (χειρότερη από του σωρού όπου είναι Ο(n))<br>
pqueue_remove_max: πολυπλοκότητα Ο(1) αφού απλά αφαιείται ο πρώτος κόμβος της λίστας, και η αφαίρεση ενός κόμβου έχει σταθερή πολυπλοκότητα (καλύτερη από του σωρού όπου είναι Ο(logn))<br>
pqueue_set_destroy_value: πολυπλοκότητα Ο(1) γιατί απλά αλλάζει ένα μέλος του struct της λίστας, ανεξάρτητα από το μέγεθός της (ίδια με του σωρού)<br>
pqueue_destroy: πολυπλοκότητα Ο(n) αφού πρέπει να απελευθερώνεται κάθε ένας από τους n+1 (μαζί με τον dummy) κόμβους της λίστας (ίδια με του σωρού, εκτός αν destroy_value == NULL, όπου του σωρού είναι Ο(1))